# algorithm_study

## 개인적으로 알고리즘과 자료구조를 공부하기 위한 프로젝트입니다.

### Basic Sort
* Insersion Sort
* Selection Sort
* Bubble Sort

### Divide and Conquer Sort
* Quick Sort

### 실행속도
###### (1 ~ 100,000개의 숫자중 랜덤으로 뽑은 100,000개의 숫자를 정렬을 100번 실행한 평균)
* Insersion Sort = 4238ms
* Selection Sort = 1302ms
* Bubble Sort = 14636ms

---

* Quick Sort = 11ms

### 시간복잡도
* Insersion Sort
```
기본로직
1. 현재 인덱스를 별도로 저장해두며,현재 인덱스는0부터 시작한다.
2. 별도로 저장해둔 인덱스와 그 앞 인덱스의 배열 값을 비교한다.
3. 만약 별도로 저장해둔 인덱스의 배열 값이 더 크다면 두 배열 값을 서로 바꿔준다.
4. 현재 인덱스를 -1 하며 3번 과정을 반복한다.
5. 1 ~ 4번 과정을 배열의 길이만큼 반복한다.
```
삽입 정렬 알고리즘은 최악의 경우(역으로 정렬되어 있을 경우)에 n-1, n-2, .... , 1개씩 비교하기 때문에 시간복잡도는 빅오표기법으로 O(N^2)가 된다.

* Selection Sort
```
기본로직
1. 정렬되지 않은 인덱스의 맨 앞부터 배열 값중 가장 작은 값을 찾는다.
2. 가장 작은 값의 배열 값을 현재 인덱스의 배열 값과 바꿔준다.
3. 다음 인덱스로 넘어간 후 1 ~ 2번 과정을 배열의 길이만큼 반복한다.
```
선택 정렬 알고리즘은 배열의 전체를 비교하기 때문에 시간복잡도는 빅오표기법으로 O(N^2)가 된다.

* Bubble Sort
```
기본로직
1. 기본 인덱스는 1부터 시작한다.
2. 현재 인덱스의 배열값과 현재 인덱스에 -1한 인덱스의 배열값을 비교한다.
3. 앞의 인덱스의 배열값이 뒤의 인덱스의 배열값 보다 크다면 서로 배열값을 바꿔준다.
4. 1 ~ 3번 과정을 끝마치면 가장 큰 배열값이 가장 뒤로 이동해 있기 때문에 마지막은 정렬에서 제외한다.
5. 1 ~ 3번 과정을 배열의 크기 만큼 반복한다.
```
버블 정렬 알고리즘은 선택 정렬과 같이 전체를 비교하기 때문에 시간복잡도는 빅오표기법으로 O(N^2)가 된다.

---

* Quick Sort
```
기본로직
1. 인덱스의 맨 앞의 인덱스를 피벗으로 정한다.
2. 분할 전 비교를 진행하기 위해 피벗을 제외한 가장 왼쪽 배열의 인덱스를 저장하는 start, 가장 오른쪽 배열의 인덱스를 저장하는 end변수를 만든다.
3. start부터 비교를 진행하며 비교는 end가 start보다 클 때만 반복한다.
4. 비교한 배열값이 피벗의 배열 값 보다 작으면 start를 하나 증가시키며 비교를 반복한다. 피벗의 배열 값 보다 큰 값을 찾으면 반복을 멈춘다.
5. 4번이 끝나면 end의 비교를 진행하며 비교는 end가 start보다 클 때만 반복한다.
6. 비교한 배열 값이 피벗의 배열 값 보다 크면 end를 하나 감소시키며 비교를 반복한다. 피벗의 배열 값 보다 작은 값을 찾으면 반복을 멈춘다.
7. 만약 start가 end보다 크거나 같다면 피벗의 배열 값과 end의 배열 값을 바꿔준다.
8. 그렇지 않다면 start의 배열 값과 end의 배열 값을 바꿔준다.
9. 맨 처음 부터 end - 1까지, end + 1부터 맨 끝까지 2부분으로 나눠 퀵정렬을 반복한다.
```
퀵정렬은 분할과 동시에 정렬을 진행하는 알고리즘이다. 각 정렬은 배열의 크기 N만큼 비교하며, 이를 총 분할 깊이인 logN만큼 진행한다. 그러므로 시간복잡도는 빅오표기법으로 O(NlogN)이다.

###### ※ 퀵정렬은 무조건 O(NlogN)을 보장하지 않고 최악의 경우 O(N^2)의 시간복잡도를 가진다.